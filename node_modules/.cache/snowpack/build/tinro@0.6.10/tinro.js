import { SvelteComponentDev, init, safe_not_equal, dispatch_dev, validate_slots, create_slot, update_slot_base, get_all_dirty_from_scope, get_slot_changes, transition_in, transition_out, empty, insert_dev, group_outros, check_outros, detach_dev } from 'svelte/internal';
import { getContext, hasContext, tick, setContext, onMount } from 'svelte';
import { writable } from 'svelte/store';

function p(e,a=!1){return e=e.slice(e.startsWith("/#")?2:0,e.endsWith("/*")?-2:void 0),e.startsWith("/")||(e="/"+e),e==="/"&&(e=""),a&&!e.endsWith("/")&&(e+="/"),e}function d(e,a){e=p(e,!0),a=p(a,!0);let r=[],n={},t=!0,c=e.split("/").map(s=>s.startsWith(":")?(r.push(s.slice(1)),"([^\\/]+)"):s).join("\\/"),o=a.match(new RegExp(`^${c}$`));return o||(t=!1,o=a.match(new RegExp(`^${c}`))),o?(r.forEach((s,h)=>n[s]=o[h+1]),{exact:t,params:n,part:o[0].slice(0,-1)}):null}function x(e,a,r){if(r==="")return e;if(r[0]==="/")return r;let n=o=>o.split("/").filter(s=>s!==""),t=n(e),c=a?n(a):[];return "/"+c.map((o,s)=>t[s]).join("/")+"/"+r}function m(e,a,r,n){let t=[a,"data-"+a].reduce((c,o)=>{let s=e.getAttribute(o);return r&&e.removeAttribute(o),s===null?c:s},!1);return !n&&t===""?!0:t||n||!1}function S(e){let a=e.split("&").map(r=>r.split("=")).reduce((r,n)=>{let t=n[0];if(!t)return r;let c=n.length>1?n[n.length-1]:!0;return typeof c=="string"&&c.includes(",")&&(c=c.split(",")),r[t]===void 0?r[t]=[c]:r[t].push(c),r},{});return Object.entries(a).reduce((r,n)=>(r[n[0]]=n[1].length>1?n[1]:n[1][0],r),{})}function v(e){return Object.entries(e).map(([a,r])=>r?r===!0?a:`${a}=${Array.isArray(r)?r.join(","):r}`:null).filter(a=>a).join("&")}function w(e,a){return e?a+e:""}function k(e){throw new Error("[Tinro] "+e)}var i={HISTORY:1,HASH:2,MEMORY:3,OFF:4,run(e,a,r,n){return e===this.HISTORY?a&&a():e===this.HASH?r&&r():n&&n()},getDefault(){return !window||window.location.pathname==="srcdoc"?this.MEMORY:this.HISTORY}};var R,M,$,b="",l=A();function A(){let e=i.getDefault(),a,r=o=>window.onhashchange=window.onpopstate=R=null,n=o=>a&&a(y(e)),t=o=>{o&&(e=o),r(),e!==i.OFF&&i.run(e,s=>window.onpopstate=n,s=>window.onhashchange=n)&&n();},c=o=>{let s=Object.assign(y(e),o);return s.path+w(v(s.query),"?")+w(s.hash,"#")};return {mode:t,get:o=>y(e),go(o,s){E(e,o,s),n();},start(o){a=o,t();},stop(){a=null,t(i.OFF);},set(o){this.go(c(o),!o.path);},methods(){return _(this)},base:o=>b=o}}function E(e,a,r){!r&&(M=$);let n=t=>history[`${r?"replace":"push"}State`]({},"",t);i.run(e,t=>n(b+a),t=>n(`#${a}`),t=>R=a);}function y(e){let a=window.location,r=i.run(e,t=>(b?a.pathname.replace(b,""):a.pathname)+a.search+a.hash,t=>String(a.hash.slice(1)||"/"),t=>R||"/"),n=r.match(/^([^?#]+)(?:\?([^#]+))?(?:\#(.+))?$/);return $=r,{url:r,from:M,path:n[1]||"",query:S(n[2]||""),hash:n[3]||""}}function _(e){let a=()=>e.get().query,r=o=>e.set({query:o}),n=o=>r(o(a())),t=()=>e.get().hash,c=o=>e.set({hash:o});return {hash:{get:t,set:c,clear:()=>c("")},query:{replace:r,clear:()=>r(""),get(o){return o?a()[o]:a()},set(o,s){n(h=>(h[o]=s,h));},delete(o){n(s=>(s[o]&&delete s[o],s));}}}}var f=T();function T(){let{subscribe:e}=writable(l.get(),a=>{l.start(a);let r=P(l.go);return ()=>{l.stop(),r();}});return {subscribe:e,goto:l.go,params:Q,meta:O,useHashNavigation:a=>l.mode(a?i.HASH:i.HISTORY),mode:{hash:()=>l.mode(i.HASH),history:()=>l.mode(i.HISTORY),memory:()=>l.mode(i.MEMORY)},base:l.base,location:l.methods()}}function Y(e){let a,r,n,t,c=()=>{a=m(e,"href").replace(/^\/#|[?#].*$|\/$/g,""),r=m(e,"exact",!0),n=m(e,"active-class",!0,"active");},o=()=>{let s=d(a,t);s&&(s.exact&&r||!r)?e.classList.add(n):e.classList.remove(n);};return c(),{destroy:f.subscribe(s=>{t=s.path,o();}),update:()=>{c(),o();}}}function P(e){let a=r=>{let n=r.target.closest("a[href]"),t=n&&m(n,"target",!1,"_self"),c=n&&m(n,"tinro-ignore"),o=r.ctrlKey||r.metaKey||r.altKey||r.shiftKey;if(t=="_self"&&!c&&!o&&n){let s=n.getAttribute("href").replace(/^\/#/,"");/^\/\/|^#|^[a-zA-Z]+:/.test(s)||(r.preventDefault(),e(s.startsWith("/")?s:n.href.replace(window.location.origin,"")));}};return addEventListener("click",a),()=>removeEventListener("click",a)}function Q(){return getContext("tinro").meta.params}var g="tinro",K=j({pattern:"",matched:!0});function q(e){let a=getContext(g)||K;(a.exact||a.fallback)&&k(`${e.fallback?"<Route fallback>":`<Route path="${e.path}">`}  can't be inside ${a.fallback?"<Route fallback>":`<Route path="${a.path||"/"}"> with exact path`}`);let r=e.fallback?"fallbacks":"childs",n=writable({}),t=j({fallback:e.fallback,parent:a,update(c){t.exact=!c.path.endsWith("/*"),t.pattern=p(`${t.parent.pattern||""}${c.path}`),t.redirect=c.redirect,t.firstmatch=c.firstmatch,t.breadcrumb=c.breadcrumb,t.match();},register:()=>(t.parent[r].add(t),async()=>{t.parent[r].delete(t),t.parent.activeChilds.delete(t),t.router.un&&t.router.un(),t.parent.match();}),show:()=>{e.onShow(),!t.fallback&&t.parent.activeChilds.add(t);},hide:()=>{e.onHide(),t.parent.activeChilds.delete(t);},match:async()=>{t.matched=!1;let{path:c,url:o,from:s,query:h}=t.router.location,u=d(t.pattern,c);if(!t.fallback&&u&&t.redirect&&(!t.exact||t.exact&&u.exact)){let L=x(c,t.parent.pattern,t.redirect);return f.goto(L,!0)}t.meta=u&&{from:s,url:o,query:h,match:u.part,pattern:t.pattern,breadcrumbs:t.parent.meta&&t.parent.meta.breadcrumbs.slice()||[],params:u.params,subscribe:n.subscribe},t.breadcrumb&&t.meta&&t.meta.breadcrumbs.push({name:t.breadcrumb,path:u.part}),n.set(t.meta),u&&!t.fallback&&(!t.exact||t.exact&&u.exact)&&(!t.parent.firstmatch||!t.parent.matched)?(e.onMeta(t.meta),t.parent.matched=!0,t.show()):t.hide(),u&&t.showFallbacks();}});return setContext(g,t),onMount(()=>t.register()),t}function O(){return hasContext(g)?getContext(g).meta:k("meta() function must be run inside any `<Route>` child component only")}function j(e){let a={router:{},exact:!1,pattern:null,meta:null,parent:null,fallback:!1,redirect:!1,firstmatch:!1,breadcrumb:null,matched:!1,childs:new Set,activeChilds:new Set,fallbacks:new Set,async showFallbacks(){if(!this.fallback&&(await tick(),this.childs.size>0&&this.activeChilds.size==0||this.childs.size==0&&this.fallbacks.size>0)){let r=this;for(;r.fallbacks.size==0;)if(r=r.parent,!r)return;r&&r.fallbacks.forEach(n=>{if(n.redirect){let t=x("/",n.parent.pattern,n.redirect);f.goto(t,!0);}else n.show();});}},start(){this.router.un||(this.router.un=f.subscribe(r=>{this.router.location=r,this.pattern!==null&&this.match();}));},match(){this.showFallbacks();}};return Object.assign(a,e),a.start(),a}

/* node_modules/tinro/cmp/Route.svelte generated by Svelte v3.44.3 */

const get_default_slot_changes = dirty => ({
	params: dirty & /*params*/ 2,
	meta: dirty & /*meta*/ 4
});

const get_default_slot_context = ctx => ({
	params: /*params*/ ctx[1],
	meta: /*meta*/ ctx[2]
});

// (33:0) {#if showContent}
function create_if_block(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, params, meta*/ 262)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, get_default_slot_changes),
						get_default_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(33:0) {#if showContent}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*showContent*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*showContent*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*showContent*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Route', slots, ['default']);
	let { path = '/*' } = $$props;
	let { fallback = false } = $$props;
	let { redirect = false } = $$props;
	let { firstmatch = false } = $$props;
	let { breadcrumb = null } = $$props;
	let showContent = false;
	let params = {}; /* DEPRECATED */
	let meta = {};

	const route = q({
		fallback,
		onShow() {
			$$invalidate(0, showContent = true);
		},
		onHide() {
			$$invalidate(0, showContent = false);
		},
		onMeta(newmeta) {
			$$invalidate(2, meta = newmeta);
			$$invalidate(1, params = meta.params); /* DEPRECATED */
		}
	});

	const writable_props = ['path', 'fallback', 'redirect', 'firstmatch', 'breadcrumb'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Route> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('path' in $$props) $$invalidate(3, path = $$props.path);
		if ('fallback' in $$props) $$invalidate(4, fallback = $$props.fallback);
		if ('redirect' in $$props) $$invalidate(5, redirect = $$props.redirect);
		if ('firstmatch' in $$props) $$invalidate(6, firstmatch = $$props.firstmatch);
		if ('breadcrumb' in $$props) $$invalidate(7, breadcrumb = $$props.breadcrumb);
		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		createRouteObject: q,
		path,
		fallback,
		redirect,
		firstmatch,
		breadcrumb,
		showContent,
		params,
		meta,
		route
	});

	$$self.$inject_state = $$props => {
		if ('path' in $$props) $$invalidate(3, path = $$props.path);
		if ('fallback' in $$props) $$invalidate(4, fallback = $$props.fallback);
		if ('redirect' in $$props) $$invalidate(5, redirect = $$props.redirect);
		if ('firstmatch' in $$props) $$invalidate(6, firstmatch = $$props.firstmatch);
		if ('breadcrumb' in $$props) $$invalidate(7, breadcrumb = $$props.breadcrumb);
		if ('showContent' in $$props) $$invalidate(0, showContent = $$props.showContent);
		if ('params' in $$props) $$invalidate(1, params = $$props.params);
		if ('meta' in $$props) $$invalidate(2, meta = $$props.meta);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*path, redirect, firstmatch, breadcrumb*/ 232) {
			 route.update({ path, redirect, firstmatch, breadcrumb });
		}
	};

	return [
		showContent,
		params,
		meta,
		path,
		fallback,
		redirect,
		firstmatch,
		breadcrumb,
		$$scope,
		slots
	];
}

class Route extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			path: 3,
			fallback: 4,
			redirect: 5,
			firstmatch: 6,
			breadcrumb: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Route",
			options,
			id: create_fragment.name
		});
	}

	get path() {
		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set path(value) {
		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fallback() {
		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fallback(value) {
		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get redirect() {
		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set redirect(value) {
		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get firstmatch() {
		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set firstmatch(value) {
		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get breadcrumb() {
		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set breadcrumb(value) {
		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Route, Y as active, O as meta, f as router };
